@page "/ViewUserTasks/{username?}"
@inject ITaskProjectService TaskProjectService
@inject IProjectService ProjectService
@inject IUserService UserService
@inject NavigationManager NavigationManager
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using Domain.Models
@using Domain.Dtos
@using HttpClients.ClientInterfaces

<div class="title">
<h2 >@pageHeader</h2>
</div>
  


<div class="card">
    
    <div class="sorting-options">
        <label><input type="checkbox" @bind="showRequested" />Requested</label>
        <label><input type="checkbox" @bind="showInProgress" />In Progress</label>
         <label><input type="checkbox" @bind="showCompleted" />Closed</label>
        
        
        <label for="sortField">Sort by: </label>
        <select id="sortField" @onchange="(e) => ChangeSortField(e.Value.ToString())">
            <option value="Deadline">Deadline</option>
            <option value="StartDate">Start Date</option>
            <option value="Status">Status</option>
        </select>
        <button @onclick="ToggleSortDirection">@sortDirection</button>
    </div>



    @if (isLoading)
    {
        <p><em>Loading...</em></p>
    }
    else if (!string.IsNullOrEmpty(msg))
    {
        <p class="text-danger">@msg</p>
    }
    else if (groupedTasks == null || groupedTasks.Count == 0)
    {
        <p>No tasks to display.</p>
    }
    else
    {
        @foreach (var projectGroup in groupedTasks)
        {
            var projectName = projectNames.ContainsKey(projectGroup.Key) ? projectNames[projectGroup.Key] : "Unknown Project";
            <div class="project-header">
                <span class="project-link" @onclick="() => NavigateToProject(projectGroup.Key)">Project: @projectGroup.Key - @projectName</span>
                <span class="dropdown-icon" @onclick:stopPropagation="true" @onclick="() => ToggleProject(projectGroup.Key)">
                    @((expandedProjects.Contains(projectGroup.Key)) ? "▲" : "▼")
                </span>
            </div>
            @if (expandedProjects.Contains(projectGroup.Key))
            {
                <table class="table">
                    <thead>
                    <tr>
                        <th class="small-column"></th>
                        <th>Task Name</th>
                        <th>Status</th>
                        <th>Estimated Hours</th>
                        <th>Start Date</th>
                        <th>Deadline</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var task in projectGroup.Value.Select((task, index) => new { Task = task, Index = index + 1 }))
                    {
                        <tr>
                            <td class="small-column">@task.Index</td>
                            <td><a class="task-link" @onclick="() => NavigateToTask(task.Task.Id)">@task.Task.Name</a></td>
                            <td>@task.Task.TaskStatusEnum</td>
                            <td>@task.Task.Estimate</td>
                            <td>@task.Task.StartDate</td>
                            <td>@task.Task.Deadline</td>
                        </tr>
                    }
                    </tbody>
                </table>
            }
        }
    }
</div>

@code {
    [Parameter]
    public string? Username { get; set; }

    [CascadingParameter]
    public Task<AuthenticationState> AuthState { get; set; } = null!;

    private Dictionary<int, List<TaskProject>> groupedTasks = new();
    private Dictionary<int, List<TaskProject>> groupedTasksFromDatabase = new();  //data from database to use as base for filtering, never changes
    private readonly Dictionary<int, string> projectNames = new();
    private string? msg;
    private bool isLoading = true;
    private readonly HashSet<int> expandedProjects = new();
    private string pageHeader = "My Tasks";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            string? username = Username;

            if (string.IsNullOrEmpty(username))
            {
                username = await GetUsernameAsync();
                if (string.IsNullOrEmpty(username))
                {
                    msg = "User is not authenticated.";
                    return;
                }
            }
            else
            {
                var userName = await GetUserNameAsync(username);
                pageHeader = $"Tasks assigned to {userName}";
            }

            var tasks = (await TaskProjectService.GetTasksUser(username)).ToList();
            groupedTasks = tasks.GroupBy(task => task.ProjectId)
                                .ToDictionary(group => group.Key, group => group.ToList());
            groupedTasksFromDatabase = tasks.GroupBy(task => task.ProjectId)
                .ToDictionary(group => group.Key, group => group.ToList());
            foreach (var projectId in groupedTasks.Keys)
            {
                var project = await ProjectService.GetByIdAsync(projectId);
                if (project != null)
                {
                    projectNames[projectId] = project.ProjectName;
                }
            }

            // Initially expand all project sections
            expandedProjects.UnionWith(groupedTasks.Keys);
            
            // Initialize filteredTasks to show all tasks initially
           // filteredTasks = new Dictionary<int, List<TaskProject>>(groupedTasks);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            msg = e.Message;
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task<string?> GetUsernameAsync()
    {
        var authState = await AuthState;
        var user = authState.User;

        var usernameClaim = user.Claims.FirstOrDefault(claim => claim.Type == "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name");
        if (usernameClaim == null)
        {
            return null;
        }

        return usernameClaim.Value;
    }

    private async Task<string> GetUserNameAsync(string username)
    {
        var user = await UserService.GetByUsernameAsync(username);
        return user?.Name ?? username;
    }

    private void ToggleProject(int projectId)
    {
        if (expandedProjects.Contains(projectId))
        {
            expandedProjects.Remove(projectId);
        }
        else
        {
            expandedProjects.Add(projectId);
        }
    }

    private void NavigateToTask(int taskId)
    {
        NavigationManager.NavigateTo($"/oneTask/{taskId}");
    }

    private void NavigateToProject(int projectId)
    {
        NavigationManager.NavigateTo($"/oneProject/{projectId}");
    }
    
    //Sorting
   
       // Sorting properties
       private string sortField = "Name"; // Default sorting field
       private bool isAscending = true;
       private string sortDirection => isAscending ? "Ascending" : "Descending";

       // Sorting logic
       private void ChangeSortField(string? field)
       {
           if (!string.IsNullOrEmpty(field))
           {
               sortField = field;
               ApplySorting();
           }
       }

       private void ToggleSortDirection()
       {
           isAscending = !isAscending;
           ApplySorting();
       }

    private void ApplySorting()
    {
        foreach (var projectId in groupedTasks.Keys.ToList())
        {
            var sortedTasks = sortField switch
            {
                "Deadline" => isAscending
                    ? groupedTasks[projectId].OrderBy(task => task.Deadline).ToList()  // Convert to List
                    : groupedTasks[projectId].OrderByDescending(task => task.Deadline).ToList(),

                "StartDate" => isAscending
                    ? groupedTasks[projectId].OrderBy(task => task.StartDate).ToList()  // Convert to List
                    : groupedTasks[projectId].OrderByDescending(task => task.StartDate).ToList(),

                "Status" => isAscending
                    ? groupedTasks[projectId].OrderBy(task => task.TaskStatusEnum.ToString()).ToList()  // Convert to List
                    : groupedTasks[projectId].OrderByDescending(task => task.TaskStatusEnum.ToString()).ToList(),

                _ => groupedTasks[projectId] // Default, no sorting
                };

            groupedTasks[projectId] = sortedTasks;  // Now it is a List<TaskProject>
        }

        StateHasChanged();
    }

//display tasks checkboxes requested, in progress, completed


    private void ApplyFiltering()
    {
        groupedTasks = groupedTasksFromDatabase
            .Where(group => group.Value.Any(task =>
                (showRequested && task.TaskStatusEnum == TaskStatusEnum.Requested) ||
                (showCompleted && (task.TaskStatusEnum == TaskStatusEnum.Completed ||
                 task.TaskStatusEnum == TaskStatusEnum.NotApproved)) ||
                (showInProgress && task.TaskStatusEnum != TaskStatusEnum.Requested &&
                 task.TaskStatusEnum != TaskStatusEnum.Completed &&
                 task.TaskStatusEnum != TaskStatusEnum.NotApproved)
                ))
            .ToDictionary(
                group => group.Key,
                group => group.Value.Where(task =>
                    (showRequested && task.TaskStatusEnum == TaskStatusEnum.Requested) ||
                    (showCompleted && (task.TaskStatusEnum == TaskStatusEnum.Completed ||
                     task.TaskStatusEnum == TaskStatusEnum.NotApproved)) ||
                    (showInProgress && task.TaskStatusEnum != TaskStatusEnum.Requested &&
                     task.TaskStatusEnum != TaskStatusEnum.Completed &&
                     task.TaskStatusEnum != TaskStatusEnum.NotApproved)
                    ).ToList()
            );

        StateHasChanged();  //refresh UI
    }

    private bool _showRequested = true;
    private bool _showCompleted = true;
    private bool _showInProgress = true;

    private bool showRequested
    {
        get => _showRequested;
        set
        {
            if (_showRequested != value)
            {
                _showRequested = value;
                ApplyFiltering();
            }
        }
    }

    private bool showCompleted
    {
        get => _showCompleted;
        set
        {
            if (_showCompleted != value)
            {
                _showCompleted = value;
                ApplyFiltering();
            }
        }
    }

    private bool showInProgress
    {
        get => _showInProgress;
        set
        {
            if (_showInProgress != value)
            {
                _showInProgress = value;
                ApplyFiltering();
            }
        }
    }



}